
# Derivation of Grammar and PDA ‚öôÔ∏è
- **Full Names:**  
  - Mat√≠as Martinez Moreno  
  - Samuel Orozco Valencia  

- **Class:**  
  - Wednesday SI2002-2 (7309)  

---
> **Readings 23 and 24 from Kozen (1997) were used as references for the concepts of Pushdown Automata and Context-Free Grammars applied in this project.**  
> Kozen, D. C. (1997). *Automata and Computability.* Springer-Verlag, Berlin, Heidelberg.  
---

## About this Project üöÄ

This project implements three algorithms in C++ that demonstrate the analysis and processing ofa context-free grammar and its corresponding Pushdown Automaton (PDA). The grammar used is:

> **G:**  
> **S ‚Üí aSb | Œµ**

1. **Algorithm 1:**  
   - Generates strings that belong to the language defined by the grammar (accepted strings) and strings that do not belong.  
   - The generated strings are displayed and stored in the file `Cadenas_generadas.txt`.  

2. **Algorithm 2:**  
   - Implements a PDA that recognizes the strings generated by grammar G.  
   - The PDA processes the input symbol by symbol, managing a stack and recording each configuration.  
   - Accepted strings are stored in the file `Cadenas_aceptadas.txt`.  

3. **Algorithm 3:**  
   - Reads the accepted strings from `Cadenas_aceptadas.txt` and builds a table showing a leftmost derivation for each string along with the corresponding PDA configurations.  
   - The table is displayed in three columns:  
     - **Column 1:** The production rule applied  
     - **Column 2:** The sentential form obtained after applying the rule  
     - **Column 3:** The PDA configuration in the form *(q, Stack, remaining input string)*  

---
## Environment and Tools Used üíª

- **Operating System:**  
  - Windows 11  

- **Programming Language:**  
  - C++ (compiled using g++)  

- **Required Tools:**  
  - Visual Studio Code (IDE/Editor)  
  - MSYS2 /MinGW (Compilation)  
  - Command Prompt / Terminal  

---

## Project File Structure üìÅ

- **ALGORITHM_1_LFCO_2025_MM_SA.cpp**  
- **ALGORITHM_2_LFCO_2025_MM_SA.cpp**  
- **ALGORITHM_3_LFCO_2025_MM_SA.cpp**  
- **Main.cpp:**  
  The file (`Main.cpp`) includes the three algorithms,executing them sequentially without requiring user input. All output is displayed in the console.  

---

## How to Compile and Run the Project ‚ùì

1. **Preparation:**  
   - Place all files (`ALGORITHM_1_LFCO_2025_MM_SA.cpp`, `ALGORITHM_2_LFCO_2025_MM_SA.cpp`, `ALGORITHM_3_LFCO_2025_MM_SA.cpp`, and `Main.cpp`) in the same directory.  

2. **Compilation:**  
   - Open the Command Prompt (CMD).  
   - Navigate to the directory containing the source files.  
   - Compile the project by running:  
     ```
     g++ Main.cpp -o SimulacionPDA.exe
     ```
     (Since `Main.cpp` includes the other source files, compiling this single file is sufficient.)  

3. **Execution:**  
   - Then, run the executable:  
     ```
     .\SimulacionPDA.exe
     ```
   - The program will run automatically without requiring any user input.  
   - **The important output will be displayed in the console**, and two additional files will be generated, which were only for the purposes of the program's internal execution:  
     - `Cadenas_generadas.txt` ‚Äì contains all generated strings.  
     - `Cadenas_aceptadas.txt` ‚Äì contains only the strings accepted by the PDA.  

---
# Explanation of the Algorithms üîç

## 1. ALGORITHM_1: String Generation
This modulegenerates **valid** and **invalid** strings according to the production rule. The generated strings are printed to the console and saved in the file `Cadenas_generadas.txt`, which will serve as input for the second algorithm.

### Important Functions

#### `generarCadenaValida`

Generates a valid string recursively based on the production **S ‚Üí aSb | Œµ**.

```cpp
string generarCadenaValida(int profundidad) {
    if (profundidad <= 0) return ""; // Base case: empty string
    return "a" + generarCadenaValida(profundidad - 1) + "b";
}
```

#### `generarCadenaValidaAleatoria`

Selects a random depth (between 1 and a given maximum (12 in the case we implemented)) and generates a valid string using `generarCadenaValida`.

```cpp
string generarCadenaValidaAleatoria(int profundidadMaxima) {
    int profundidad = rand() % profundidadMaxima + 1;
    return generarCadenaValida(profundidad);
}
```

#### `generarCadenaInvalida`

Generates an invalid string using the same alphabet `{a, b}`. If the randomly generated string accidentally follows the a‚Åøb‚Åø pattern, a character is altered to break its validity.

```cpp
string generarCadenaInvalida() {
    int longitud = rand() % 6 + 1; 
    string cadena;
    for (int i = 0; i < longitud; i++) {
        char caracter = (rand() % 2 == 0) ? 'a' : 'b';
        cadena.push_back(caracter);
    }
    // Check if the string follows the form a^n b^n
    int conteoA = 0, conteoB = 0;
    for (char caracter : cadena) {
        if (caracter == 'a') conteoA++; else conteoB++;
    }
    bool esValida = false;
    if (conteoA == conteoB && conteoA > 0) {
        // Verify if it is a^n b^n
        esValida = true;
        for (int i = 0; i < conteoA; i++) {
            if (cadena[i] != 'a') { esValida = false; break; }
        }
        for (int i = conteoA; i < (int)cadena.size(); i++) {
            if (cadena[i] != 'b') { esValida = false; break; }
        }
    }
    // If the generated string is valid, alter the first symbol to invalidate it
    if (esValida && !cadena.empty()) {
        cadena[0] = (cadena[0] == 'a') ? 'b' : 'a';
    }
    return cadena;
}
```

#### `generarYGuardarCadenas`

Generates 4 valid strings and 4 invalid strings, displays them in the console, and saves them in `Cadenas_generadas.txt`.

----------

## 2. ALGORITHM_2: PDA Simulation
This module simulates a PDA that recognizes strings generated by the grammar  
 **S ‚Üí aSb | Œµ**  
 The PDA uses a stack where:  

- When reading an `'a'`, it **pushes** an `'A'`.  
- When reading a `'b'`, it **pops** from the stack.  

If an attempt is made to pop from an empty stack or an unrecognized symbol is encountered, the string is rejected.

### Key Structures and Functions

#### Structure `Configuracion`

Stores each step of the simulation with the following information:  

- **paso**  
- **indice:** Position in the input string.  
- **entradaRestante:** portion of the input yet to be processed.  
- **contenidoPila:** Current stack contents.  
- **mensaje:** Message describing the action (push, pop, error).  

#### `pilaAString`

Converts the stack contents into a string for easier visualization (with leftmost derivation).

```cpp
string pilaAString(stack<char> pila) {
    string resultado;
    while (!pila.empty()) {
        resultado += pila.top();
        pila.pop();
    }
    reverse(resultado.begin(), resultado.end());
    return resultado;
}
```

#### `simularPDAYGuardarAceptadas`

Reads the strings from `Cadenas_generadas.txt`, processes each string through the PDA, and saves only the accepted strings in `Cadenas_aceptadas.txt`, which will serve as input for the third algorithm.

----------

## 3. ALGORITHM_3: Leftmost Derivation Table and PDA Configuration

This module reads the accepted strings from `Cadenas_aceptadas.txt` and, for each string:  

- Builds a table showing the **leftmost derivation** of the string (according to the grammar **S ‚Üí aSb | Œµ**).  
- Displays the **PDA configuration** at each step of the string‚Äôs processing.  

### Key Structures and Functions

#### Structure `PasoDerivacion`

Stores each derivation step with:  

- **regla:** The production rule applied.  
- **formaSentencial:** The sentential form obtained after applying the rule.  

#### `derivacionIzquierda`

Generates the leftmost derivation for a given string:  

- Starts with the initial sentential form `S`.  
- repeatedly applies the rule **S ‚Üí aSb** based on the count of consecutive `'a'` characters.  
- finally applies the rule **S ‚Üí Œµ** to complete the derivation.  

```cpp
vector<PasoDerivacion> derivacionIzquierda(const string &x) {
    // Count the number of 'a' in the string (n)
    int n = 0;
    for (char caracter : x) {
        if (caracter == 'a')
            n++;
        else
            break;
    }
    
    vector<PasoDerivacion> derivacion;
    derivacion.push_back({"(inicio)", "S"});  // Initial step: S
    
    // Apply rule (i) n times: S -> aSb 
    for (int i = 0; i < n; i++) {
        string anterior = derivacion.back().formaSentencial;
        size_t posicion = anterior.find('S');
        if (posicion != string::npos) {
            string siguiente = anterior.substr(0, posicion) + "aSb" + anterior.substr(posicion + 1);
            derivacion.push_back({"(i) S->aSb ", siguiente});
        }
    }
    
    // Apply rule (ii): S -> Œµ 
    string anterior = derivacion.back().formaSentencial;
    size_t posicion = anterior.find('S');
    if (posicion != string::npos) {
        // Remove the S, generating the final string a^n b^n
        string siguiente = anterior.substr(0, posicion) + anterior.substr(posicion + 1);
        derivacion.push_back({"(ii) S->Œµ ", siguiente});
    }
    
    return derivacion;
}
```

#### `computacionAceptacionPDA`

Simulates the PDA processing for the given string:  

- For each `'a'`, pushes an `'A'` onto the stack.  
- For each `'b'`, pops from the stack.  
- Records each configuration before and after processing a symbol.  

#### `imprimirDerivacionYPDA`

Prints a table with three columns:  

1. Production rule applied.  
2. Sentential form derived by leftmost derivation.  
3. PDA configuration in the form _(q, Remaining Input, Stack Contents)_.  

---
## 4. MAIN: Module Integration

The `Main.cpp` file includes the other three modules and calls their functions sequentially:
